rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

  function isAuthed() {
    return request.auth != null;
  }

  function isOwner(uid) {
    return isAuthed() && request.auth.uid == uid;
  }

  function isValidUsername(username) {
    return username is string && username.matches('^[a-z0-9._]{3,20}$');
  }
    // Users collection
    match /users/{userId} {
      // Allow users to read and manage their own user document
      allow read, create: if isAuthed() && isOwner(userId);
      allow update: if isOwner(userId) &&
        // Username immutability: once set, cannot change or remove
        (!resource.data.keys().hasAny(['username']) || request.resource.data.username == resource.data.username) &&
        // When setting username for first time, validate and require usernames doc
        (!request.resource.data.username ||
         (isValidUsername(request.resource.data.username) &&
          existsAfter(/databases/$(database)/documents/usernames/$(request.resource.data.username)) &&
          getAfter(/databases/$(database)/documents/usernames/$(request.resource.data.username)).data.uid == userId));
      allow delete: if isAuthed() && isOwner(userId);

      match /friendRequestsOut/{toUid} {
        allow read, create, update: if request.auth != null && request.auth.uid == userId;

        // allow either party to delete, so accept/cancel/cleanup works
        allow delete: if request.auth != null && (request.auth.uid == userId || request.auth.uid == toUid);
      }

      match /friendRequestsIn/{fromUid} {
        // Receiver can read their incoming requests
        allow read: if request.auth != null && request.auth.uid == userId;

        // Sender can create/update ONLY the request doc whose id matches their uid
        allow create, update: if request.auth != null && request.auth.uid == fromUid;

        // Either party can delete (receiver declines OR sender cancels/cleanup)
        allow delete: if request.auth != null && (request.auth.uid == userId || request.auth.uid == fromUid);
      }

      match /friends/{friendUid} {
        allow read: if request.auth != null && request.auth.uid == userId;

        // Allow create/update for owner OR friend accepting request
        allow create, update: if request.auth != null && (
          request.auth.uid == userId ||
          (request.auth.uid == friendUid &&
           exists(/databases/$(database)/documents/users/$(friendUid)/friendRequestsIn/$(userId)))
        );

        // Keep delete as-is (unfriend)
        allow delete: if request.auth != null && (request.auth.uid == userId || request.auth.uid == friendUid);
      }

      match /stats/{docId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      match /achievements/{achievementId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Leaderboards collection - allow authenticated users to read/write
    match /leaderboards/{period} {
      match /entries/{userId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // Usernames mapping - lookup by any authenticated user; writes owner-only
    match /usernames/{username} {
      allow read: if request.auth != null;
      allow create, update: if request.auth != null
        && request.resource.data.uid == request.auth.uid;
      allow delete: if request.auth != null
        && resource.data.uid == request.auth.uid;
    }

    // Public profiles (collection: publicProfiles) - any authed user can read; owner-only write.
    // When using emulator: restart it after rule changes so it reloads this file.
    match /publicProfiles/{userId} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && request.auth.uid == userId;
    }
  }
}